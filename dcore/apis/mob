dcore.requireAPI("advitem","potion")

-- Some function that are used by the mob API functions
local function count(input)
	local int = 0
	for k,v in pairs(input) do
		int = int+1
	end
	return int
end
local function overrideTable(_a,_b)
	local c = _a
	for k,v in pairs(_b) do
		if(type(v)=="table")then
			c[k] = overrideTable(_a[k],v)
		else
			c[k] = v
		end
	end
	return c
end
local function getRandomNameWithMob(mob)
	-- Gets a randomized name for that mob
	if(mob.type=="Zombie")then
		if((mob.isBaby and mob.isBaby == 1))then return getRAE{"Baby","Tiny","Small"}.." Zombie" end
		return getRAE{"Zombie","Undead Soldier","Undead Warrior"}
	elseif(mob.type=="Skeleton")then
		local prefix = ("Wither " and (mob.skeletonType and mob.skeletonType == 1) or "")
		if(mob.equipment.weapon.id and items.getItemWithStringID(mob.equipment.weapon.id)["types"]["ranged"])then
			return getRAE{prefix.."Skeleton","Ranged "..prefix.."Skeleton",prefix.."Skeleton Archer"}
		else
			return getRAE{prefix.."Skeleton","Melee "..prefix.."Skeleton",prefix.."Skeleton Warrior"}
		end
	elseif(mob.type=="Spider")then
		return "Spider"
	elseif(mob.type=="Creeper")then
		return "Creeper"
	elseif(mob.type=="Ozelot")then
		return "Cat"
	elseif(mob.type=="PigZombie")then
		if((mob.isBaby and mob.isBaby == 1))then return getRAE{"Baby","Tiny","Small"}.." Pigmen" end
		return getRAE{"Zombie Pigmen","Undead Pigmen","Undead Walking Pig"}
	end
end



--  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
-- Equipment data so mobs know what to spawn with
local mobData = {}
-- {{ID,CHANCE},{ID,CHANCE},...}
-- Just to save some space
local defaultEffects = {{1,0.4},{5,0.2},{8,0.1},{11,.3},{12,.3},{14,.02},{21,.03},{22,.02}}
mobData["Zombie"] = {weapon = {"melee"},boots = {"boots"},leggings = {"leggings"},chestplate = {"chestplate"},helmet = {"helmet"},rideable = false,acceptableEffects = defaultEffects}
mobData["PigZombie"] = {weapon = {"melee"},boots = {"boots"},leggings = {"leggings"},chestplate = {"chestplate"},helmet = {"helmet"},rideable = false,acceptableEffects = defaultEffects}
mobData["Skeleton"] = {weapon = {"melee","ranged"},boots = {"boots"},leggings = {"leggings"},chestplate = {"chestplate"},helmet = {"helmet"},rideable = false,acceptableEffects = defaultEffects}
mobData["Spider"] = {rideable = function(mob) return (mob.type == "Skeleton" and mob.equipment.weapon.id and items.getItemWithStringID(mob.equipment.weapon.id) and math.random(10) == 1) or (mob.type == "Creeper" and math.random(20) == 1) end,acceptableEffects = defaultEffects}
mobData["Ozelot"] = {rideable = function() return false end,acceptableEffects = defaultEffects}
mobData["Creeper"] = {rideable = false,acceptableEffects = defaultEffects}
--  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --

function newMob(args)
	local args = args or {}
	local mobObject = {}
	mobObject.riding = nil
	mobObject.equipment = {weapon = {},boots = {},leggings = {},chestplate = {},helmet = {}}
	mobObject.type = args.type or "Skeleton"
	mobObject.potionEffects = {}
	mobObject.name = ""
	mobObject.dropChances = {"0.5f","0.5f","0.5f","0.5f","0.5f"}
	mobObject.difficulty = args.difficulty
	mobObject.level = 1
	mobObject.doesDespawn = false
	mobObject.customNameVisible = false
	
	-- Insert argument validation and checking here
	if(args.noAI)then mobObject.noAI = args.noAI end
	
	
	--
	
	-- Manual Property Setting
	mobObject.setDifficulty = function(self,value) self.difficulty = value return self end
	mobObject.setMobType = function(self,value) self.type = value return self end
	mobObject.setDifficulty = function(self,value) self.difficulty = value return self end
	mobObject.setMount = function(self,value) self.riding = value return self end
	mobObject.setDoespawning = function(self,value) self.doesDespawn = value return self end
	mobObject.setDropChances = function(self,value) self.dropChances = value return self end
	mobObject.setCustomNameVisible = function(self,value) self.customNameVisible = value return self end
	--
	
	-- Equipment Handling
	mobObject.setEquipment = function(self,part,item)
		if(item)then
			-- Check if item is item object
			self.equipment[part] = item
		else
			-- Let's just assume it has the right format!
			self.equipment = part
		end
		return self
	end
	mobObject.autoEquipment = function(self)
		local equipment = {}
		for _,v in pairs{"weapon","boots","leggings","chestplate","helmet"} do
			local item = advitem.newItem({itemType = getRAE(mobData[self.type][v]),itemLevel = self.difficulty}):auto()
			local itemTable = item:getNBT()
			if(itemTable.id)then
				itemTable["Count"] = 1
				self.equipment[v] = itemTable
				self.level = self.level + (math.floor((item.value/50)+1.5)/10)
			end
		end
		return self
	end
	--

	-- Potion Effect Handling
	mobObject.autoPotions = function(self)
		local mobsEffectTable = mobData[self.type].acceptableEffects
		local difficultyOfMob = self.difficulty
		local active_effects = {}
		local effectsApplied = 0 -- how many effects we have
		
		-- Randomizing the effects a mob will get
		while(math.random(difficultyOfMob)<difficultyOfMob-(10+20*effectsApplied)+(math.floor(difficultyOfMob)*.65))do
			local effect = 0
			local timeout = 30
			
			while timeout>0 do
				effect = math.random(#mobsEffectTable)
				if(math.floor(mobsEffectTable[effect][2]*difficultyOfMob+1)>math.random(difficultyOfMob))then
					if((active_effects[mobsEffectTable[effect][1]] or 0) < potion.getPotionTableByID(mobsEffectTable[effect][1])["max"] or potion.getPotionTableByID(mobsEffectTable[effect][1])["max"] < 0)then
						active_effects[mobsEffectTable[effect][1]] = (active_effects[mobsEffectTable[effect][1]] or 0) + 1
						self.level = self.level + 3
						break
					end
				end
				timeout = timeout - 1
			end
			effectsApplied = effectsApplied + 1
		end
		-- Parsing those effects for usage in NBT
		if(count(active_effects)>0)then
			local eTable = self.potionEffects
			for k,v in pairs(active_effects) do -- Apply Potion Effects
				if(active_effects[k]~=nil)then
					table.insert(eTable,{["Id"] = k,["Amplifier"] = v,["Duration"] = 99999,["Ambient"] = 0,["ShowParticles"] = 0})
					self.level = self.level + (v*3)
				end
			end
			self.potionEffects = eTable
		end
		return self
	end
	--
	
	mobObject.autoType = function(self)
		local t = {}
		for k,_ in pairs(mobData) do t[#t+1] = k end
		local cT = getRAE(t)
		
	end
	mobObject.autoName = function(self)
		self.name = "Lv. "..math.floor(self.level+0.5).." "..getRandomNameWithMob(self)
		return self
	end
	
	-- Wrapping things up
	mobObject.auto = function(self)
		return self:autoEquipment():autoPotions():autoName()
	end
	
	mobObject.getNBTTable = function(self)
		local t = {
			["ActiveEffects"] = self.potionEffects,
			["Equipment"] = {self.equipment.weapon,self.equipment.boots,self.equipment.leggings,self.equipment.chestplate,self.equipment.helmet},
			["PersistenceRequired"] = "0b" and self.doesDespawn or "1b",
			["DropChances"] = self.dropChances,
			["CustomNameVisible"] = self.customNameVisible,
			["CustomName"] = self.name,
			["Riding"] = self.riding
		}
		if(self.noAI)then t["NoAI"] = true end
		return t
	end
	
	mobObject.getSummonCommand = function(self,x,y,z)
		return "/summon "..self.type.." "..x.." "..y.." "..z.." "..dcore.getNBTStringFromTable(self:getNBTTable())
	end
	
	mobObject.summon = function(self,x,y,z)
		return commands.exec(self:getSummonCommand(x,y,z))		
	end
	
	
	return mobObject
end

