-- -*- coding: utf-8 -*-
-- Simple JSON encoding and decoding in pure Lua.
-- Copyright 2010-2014 Jeffrey Friedl (http://regex.info/blog/)
-- Latest version: http://regex.info/blog/lua/json
-- This code is released under a Creative Commons CC-BY "Attribution" License: http://creativecommons.org/licenses/by/3.0/deed.en_US
--
-- Sorry Jeffrey, we had to shorten this, 26kb was waaay to much for us! ~ @Wergat
local a=20141223.14;local b="-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json) version 20141223.14 ]-"local OBJDEF={VERSION=a,AUTHOR_NOTE=b}local c="  "local d={pretty=true,align_keys=false,indent=c}local e={__tostring=function()return"JSON array"end}e.__index=e;local f={__tostring=function()return"JSON object"end}f.__index=f;function OBJDEF:newArray(g)return setmetatable(g or{},e)end;function OBJDEF:newObject(g)return setmetatable(g or{},f)end;local function h(i)if i<=127 then return string.char(i)elseif i<=2047 then local j=math.floor(i/0x40)local k=i-0x40*j;return string.char(0xC0+j,0x80+k)elseif i<=65535 then local j=math.floor(i/0x1000)local l=i-0x1000*j;local m=math.floor(l/0x40)local k=l-0x40*m;j=0xE0+j;m=0x80+m;k=0x80+k;if j==0xE0 and m<0xA0 or j==0xED and m>0x9F or j==0xF0 and m<0x90 or j==0xF4 and m>0x8F then return"?"else return string.char(j,m,k)end else local j=math.floor(i/0x40000)local l=i-0x40000*j;local n=math.floor(l/0x1000)l=l-0x1000*n;local o=math.floor(l/0x40)local k=l-0x40*o;return string.char(0xF0+j,0x80+n,0x80+o,0x80+k)end end;function OBJDEF:onDecodeError(p,q,r,s)if q then if r then p=string.format("%s at char %d of: %s",p,r,q)else p=string.format("%s: %s",p,q)end end;if s~=nil then p=p.." ("..OBJDEF:encode(s)..")"end;if self.assert then self.assert(false,p)else assert(false,p)end end;OBJDEF.onDecodeOfNilError=OBJDEF.onDecodeError;OBJDEF.onDecodeOfHTMLError=OBJDEF.onDecodeError;function OBJDEF:onEncodeError(p,s)if s~=nil then p=p.." ("..OBJDEF:encode(s)..")"end;if self.assert then self.assert(false,p)else assert(false,p)end end;local function t(self,q,u,s)local v=q:match('^-?[1-9]%d*',u)or q:match("^-?0",u)if not v then self:onDecodeError("expected number",q,u,s)end;local w=u+v:len()local x=q:match('^%.%d+',w)or""w=w+x:len()local y=q:match('^[eE][-+]?%d+',w)or""w=w+y:len()local z=v..x..y;local A=tonumber(z)if not A then self:onDecodeError("bad number",q,u,s)end;return A,w end;local function B(self,q,u,s)if q:sub(u,u)~='"'then self:onDecodeError("expected string's opening quote",q,u,s)end;local w=u+1;local C=q:len()local D=""while w<=C do local E=q:sub(w,w)if E=='"'then return D,w+1 end;if E~='\\'then D=D..E;w=w+1 elseif q:match('^\\b',w)then D=D.."\b"w=w+2 elseif q:match('^\\f',w)then D=D.."\f"w=w+2 elseif q:match('^\\n',w)then D=D.."\n"w=w+2 elseif q:match('^\\r',w)then D=D.."\r"w=w+2 elseif q:match('^\\t',w)then D=D.."\t"w=w+2 else local F=q:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',w)if F then w=w+6;local i=tonumber(F,16)if i>=0xD800 and i<=0xDBFF then local G=q:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',w)if G then w=w+6;i=0x2400+(i-0xD800)*0x400+tonumber(G,16)else end end;D=D..h(i)else D=D..q:match('^\\(.)',w)w=w+2 end end end;self:onDecodeError("unclosed string",q,u,s)end;local function H(q,u)local I,J=q:find("^[ \n\r\t]+",u)if J then return J+1 else return u end end;local K;local function L(self,q,u,s)if q:sub(u,u)~='{'then self:onDecodeError("expected '{'",q,u,s)end;local w=H(q,u+1)local D=self.strictTypes and self:newObject{}or{}if q:sub(w,w)=='}'then return D,w+1 end;local C=q:len()while w<=C do local M,N=B(self,q,w,s)w=H(q,N)if q:sub(w,w)~=':'then self:onDecodeError("expected colon",q,w,s)end;w=H(q,w+1)local O,N=K(self,q,w)D[M]=O;w=H(q,N)local E=q:sub(w,w)if E=='}'then return D,w+1 end;if q:sub(w,w)~=','then self:onDecodeError("expected comma or '}'",q,w,s)end;w=H(q,w+1)end;self:onDecodeError("unclosed '{'",q,u,s)end;local function P(self,q,u,s)if q:sub(u,u)~='['then self:onDecodeError("expected '['",q,u,s)end;local w=H(q,u+1)local D=self.strictTypes and self:newArray{}or{}if q:sub(w,w)==']'then return D,w+1 end;local Q=1;local C=q:len()while w<=C do local R,N=K(self,q,w)D[Q]=R;Q=Q+1;w=H(q,N)local E=q:sub(w,w)if E==']'then return D,w+1 end;if q:sub(w,w)~=','then self:onDecodeError("expected comma or '['",q,w,s)end;w=H(q,w+1)end;self:onDecodeError("unclosed '['",q,u,s)end;K=function(self,q,u,s)u=H(q,u)if u>q:len()then self:onDecodeError("unexpected end of string",q,nil,s)end;if q:find('^"',u)then return B(self,q,u,s)elseif q:find('^[-0123456789 ]',u)then return t(self,q,u,s)elseif q:find('^%{',u)then return L(self,q,u,s)elseif q:find('^%[',u)then return P(self,q,u,s)elseif q:find('^true',u)then return true,u+4 elseif q:find('^false',u)then return false,u+5 elseif q:find('^null',u)then return nil,u+4 else self:onDecodeError("can't parse JSON",q,u,s)end end;function OBJDEF:decode(q,s)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onDecodeError("JSON:decode must be called in method format",nil,nil,s)end;if q==nil then self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"),nil,nil,s)elseif type(q)~='string'then self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s",type(q)),nil,nil,s)end;if q:match('^%s*$')then return nil end;if q:match('^%s*<')then self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"),q,nil,s)end;if q:sub(1,1):byte()==0 or q:len()>=2 and q:sub(2,2):byte()==0 then self:onDecodeError("JSON package groks only UTF-8, sorry",q,nil,s)end;local S,T=pcall(K,self,q,1,s)if S then return T else if self.assert then self.assert(false,T)else assert(false,T)end;return nil,T end end;local function U(E)if E=="\n"then return"\\n"elseif E=="\r"then return"\\r"elseif E=="\t"then return"\\t"elseif E=="\b"then return"\\b"elseif E=="\f"then return"\\f"elseif E=='"'then return'\\"'elseif E=='\\'then return'\\\\'else return string.format("\\u%04x",E:byte())end end;local V='['..'"'..'%\\'..'%z'..'\001'..'-'..'\031'..']'local function W(T)local X=T:gsub(V,U)return'"'..X..'"'end;local function Y(self,Z,s)local _={}local a0={}local a1=false;local a2;for M in pairs(Z)do if type(M)=='string'then table.insert(_,M)elseif type(M)=='number'then table.insert(a0,M)if M<=0 or M>=math.huge then a1=true elseif not a2 or M>a2 then a2=M end else self:onEncodeError("can't encode table with a key of type "..type(M),s)end end;if#_==0 and not a1 then if#a0>0 then return nil,a2 elseif tostring(Z)=="JSON array"then return nil elseif tostring(Z)=="JSON object"then return{}else return nil end end;table.sort(_)local a3;if#a0>0 then if self.noKeyConversion then self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting",s)end;a3={}for M,R in pairs(Z)do a3[M]=R end;table.sort(a0)for I,a4 in ipairs(a0)do local a5=tostring(a4)if a3[a5]==nil then table.insert(_,a5)a3[a5]=Z[a4]else self:onEncodeError("conflict converting table with mixed-type keys into a JSON object: key "..a4 .." exists both as a string and a number.",s)end end end;return _,nil,a3 end;local encode_value;function encode_value(self,T,a6,s,a7,indent)if T==nil then return'null'elseif type(T)=='string'then return W(T)elseif type(T)=='number'then if T~=T then return"null"elseif T>=math.huge then return"1e+9999"elseif T<=-math.huge then return"-1e+9999"else return tostring(T)end elseif type(T)=='boolean'then return tostring(T)elseif type(T)~='table'then self:onEncodeError("can't convert "..type(T).." to JSON",s)else local Z=T;if type(a7)~='table'then a7={}end;if type(indent)~='string'then indent=""end;if a6[Z]then self:onEncodeError("table "..tostring(Z).." is a child of itself",s)else a6[Z]=true end;local a8;local a9,a2,a3=Y(self,Z,s)if a2 then local aa={}for w=1,a2 do table.insert(aa,encode_value(self,Z[w],a6,s,a7,indent))end;if a7.pretty then a8="[ "..table.concat(aa,", ").." ]"else a8="["..table.concat(aa,",").."]"end elseif a9 then local ab=a3 or Z;if a7.pretty then local ac={}local ad=0;for I,M in ipairs(a9)do local ae=encode_value(self,tostring(M),a6,s,a7,indent)if a7.align_keys then ad=math.max(ad,#ae)end;table.insert(ac,ae)end;local af=indent..tostring(a7.indent or"")local ag=af..string.rep(" ",ad)..a7.align_keys and"  "or""local ah="%s%"..string.format("%d",ad).."s: %s"local ai={}for w,M in ipairs(a9)do local aj=encode_value(self,ab[M],a6,s,a7,ag)table.insert(ai,string.format(ah,af,ac[w],aj))end;a8="{\n"..table.concat(ai,",\n").."\n"..indent.."}"else local ak={}for I,M in ipairs(a9)do local aj=encode_value(self,ab[M],a6,s,a7,indent)local al=encode_value(self,tostring(M),a6,s,a7,indent)table.insert(ak,string.format("%s:%s",al,aj))end;a8="{"..table.concat(ak,",").."}"end else a8="[]"end;a6[Z]=false;return a8 end end;function OBJDEF:encode(T,s,a7)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onEncodeError("JSON:encode must be called in method format",s)end;return encode_value(self,T,{},s,a7 or nil)end;function OBJDEF:encode_pretty(T,s,a7)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onEncodeError("JSON:encode_pretty must be called in method format",s)end;return encode_value(self,T,{},s,a7 or d)end;function OBJDEF.__tostring()return"JSON encode/decode package"end;OBJDEF.__index=OBJDEF;function OBJDEF:new(am)local new={}if am then for M,R in pairs(am)do new[M]=R end end;return setmetatable(new,OBJDEF)end;return OBJDEF:new()