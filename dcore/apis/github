-- Initialization and stuff
function init()
	-- Makes sure dcore is loaded
	if(not dcore)then os.loadAPI(":dungeon/dcore/apis/dcore") end
	-- Config
	config.softInit("githubDefaultRepositoryName","DungeonMap")
	config.softInit("githubDefaultUserName","wergat")
	
	
	-- Check for installed JSON API
	JSON = nil
	if(fs.exists(":dungeon/dcore/apis/JSON.lua"))then
		JSON = assert(loadfile ":dungeon/dcore/apis/JSON.lua")()
		print("Native JSON-API found!")
	else
		printError("Could not find JSON parsing file; need to download a new one! Suspecting a fresh install or corrupted API directory!")
	end

	-- /// Engine Check
	-- Check if HTTP API is enabled
	if not http then
		error("No HTTP! The updater requires connection to the internet to update the files! Please provide an internet connection or enable the HTTP API for ComputerCraft in the mod config!")
	end
	-- Check if there is an internet connection and if github is whitlisted
	if not http.get("https://api.github.com/rate_limit") then
		if not http.get("http://pastebin.com/") then
			error("We need an internet connection to update our files!")
		else
			error("If you have internet, please check your Computercraft mod config and allow api.github.com to be used, so we are allowed to download files!")
		end
	end

	if(not JSON)then
		print("JSON Parser not found. Downloading a new one!")
		local downloadedJSONFile = http.get("http://pastebin.com/raw/ALx63iW4").readAll()
		if(not downloadedJSONFile)then error("could not download the new JSON Parser - it is required for the updater!") end
		local newJSONFile = fs.open(":dungeon/dcore/apis/JSON.lua","w")
		newJSONFile.writeLine(downloadedJSONFile)
		newJSONFile.close()
		JSON = assert(loadfile ":dungeon/dcore/apis/JSON.lua")()
		if(not JSON)then error("Could not write the new JSON Parser into a file - it is required for the updater!") end
	end
end
init()


-- Key managment
local defaultKey = nil
-- Tests a key
function testKey(key)
	local x = http.get("https://api.github.com/rate_limit",{["Authorization"] = "token " .. key,}).readAll()
	return JSON:decode(x)["resources"]["core"]["remaining"]
end
-- Tests a array of Lists
-- Input: Key List
-- Output: Input list with rate limits
function testkeylist(t)
	local res = {}
	for i=1,#t do
		res[key] = testKey(t[i])
	end
	return res
end
-- // Getting a list of keys.
-- Loads a keylist from the internet
local keylist = http.get("http://pastebin.com/raw/v6PvjTAz").readAll()
if keylist then
	keylist = textutils.unserialize(keylist)
else
	error("Could not establish connection to the pastebin servers. Internet connection might be troubled.")
end





-- Management of keys
-- Picks a working key
function pickWorkingKey(t)
	local list = t
	if(not list)then list = keylist end
	local pointer = 1
	-- Pick the first working key
	while pointer <= #list do
		local key = list[pointer]
		-- Key must be above threshold
		if(testKey(key) > 60)then
			return key
		end
		pointer = pointer + 1
	end
	-- At this point all keys are invalid
end
function setDefaultKey(key)
	defaultKey = key
end
function get(url,header,key)
	if not key then
		if(defaultKey)then
			return get(url, header,defaultKey)
		else
			return http.get(url, header)
		end
	end
	header = header or {}
	header["Authorization"] = "token " .. key
	return http.get(url, header)
end
-- Returns the requested URL as a parsed Table, instead of JSON
function getRequestAsTable(url,header,key)
	local data = get(url,header,key)
	if data then
		return JSON:decode(data.readAll())
	else
		return false, "GITHUB_NO_RESPONSE"
	end
	
end
-- Simple request for a simple URL request
function request(url,header)
	local header = header or {}
	return getRequestAsTable(url,header,pickWorkingKey(keylist))
end

-- Ignore List stuff
local ignoreList = nil
function cacheIgnoreList(list)
	ignoreList = list
end
function updateIgnoreList()
	local url = "https://raw.githubusercontent.com/"..config.get("githubDefaultUserName").."/"..config.get("githubDefaultRepositoryName").."/master/.luaignore"
	local list = textutils.unserialize(get(url))
	cacheIgnoreList(list)
	return list
end
function getIgnoreList()
	if(not ignoreList)then
		updateIgnoreList()
		return ignoreList
	else
		return ignoreList
	end
end
-- Wildcard: 
function isOnIgnoreList(file)
	if(not ignoreList)then updateIgnoreList() end
	for i=1,#ignoreList do
		if(string.find(file,"^("..ignoreList[i]..")$",1) and true or false)then
			return true
		end
	end
	return false
end
--

function checkDownloadLimit()
	local currentTime = getCurrentTimeAsUNIXTimespamp()
	local githubRateTable = JSON:decode(github.get("https://api.github.com/rate_limit").readAll())
	local githubRateLimit = githubRateTable["resources"]["core"]["reset"]
	local waitTime = githubRateLimit - currentTime
	local mins = math.floor(waitTime/60)
	local secs = waitTime%60
	printError(" > Oops! It looks like you've installed the DungeonMap files too much recently. Try again in about " .. mins .. "m:" .. secs .. "s!")
	print("")
	logfile.writeLine("Oops! It looks like you've installed the DungeonMap files too much recently. Try again in about " .. mins .. "m:" .. secs .. "s!")
end


-- Downlaoding from Repository

function newUpdater()
	local updater = {}
	updater.doPrint = false
	updater.doLog = false
	updater.SHACodes = {}
	updater.setShaCodes = function(self,codes)
		self.SHACodes = {}
		if fs.exists(":dungeon/hashes") then
			local file = fs.open(":dungeon/hashes", "r")
			local data = open.readAll()
			file.close()
			self.SHACodes = textutils.unserialize(data)
		end
		return self
	end
	updater.printOnScreen = function(self,text)
		if(self.doPrint)then
			print(text)
		end
	end
	updater.writeToLog = function(self,text)
		if(self.doLog)then
			logfile.writeLine(text)
		end
	end
	updater.downloadFromDir = function(self,url)
		local handle = github.get(url)
		-- Checking for the API limitations
		if handle then handle = handle.readAll()
		else return end
		local data = JSON:decode(handle)
		self:writeToLog("Found #"..tonumber(#data).." files inside "..url)
		for i = 1, #data do
			local entry = data[i]
			local path = entry["path"]
			if (entry["sha"] == SHACodes[path] and entry["type"] ~= "dir") then
				self:writeToLog(" x Not updated: "..path)
			elseif entry["type"] == "dir" then
				self:printOnScreen("Scanning directory: " .. path)
				self:writeToLog("Downloading directory: " .. path)
				SHACodes[path] = entry["sha"]
				self:downloadFromDir(entry["url"])
			else
				--for k,v in pairs(BLACKLIST) do if(v==path)then return end end
				self:printOnScreen(" > Downloading file: " .. path)
				self:writeToLog(" > Downloading file: " .. path)
				local handle = github.get(entry["download_url"])
				local xt = ""
				if(handle)then
					xt = handle.readAll()
				end
				local open = fs.open("dungeon/" .. path, "w")
				open.write(xt)
				open.close()
				SHACodes[path] = entry["sha"]
			end
		end
		return self
	end
	updater.updateHashes = function(self)
		local handle = fs.open(":dungeon/hashes", "w")
		handle.write(textutils.serialize(self.SHACodes))
		handle.close()
		return self
	end
	
	return updater
end




