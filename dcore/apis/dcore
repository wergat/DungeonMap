-- General loading of configuration things.
if(not config)then
	print("Setting up the config!")
	os.loadAPI(":dungeon/dcore/apis/config")
	config = setmetatable(config,{__index = function(t,key) return t.get(key) end}) -- Making it easier to access config data
	config.load() -- Loading previously saved configurations
	--

	-- Setting the default configurations
	config.conditionalSet("DIR_TOTAL",":dungeon")
	config.conditionalSet("DIR_MODS",":dungeon/mods")
	config.conditionalSet("DIR_LOGS",":dungeon/logs")
	config.conditionalSet("DIR_APIS",":dungeon/dcore/apis")
	config.conditionalSet("ASYNC_TIMEOUT_MAXIMUM",20)
	config.conditionalSet("ASYNC_USE_CUSTOM_ASYNC",false)
	config.conditionalSet("ENABLE_DEVELOPER_MODE",true)
	config.conditionalSet("ENABLE_SHUTDOWN_TRIGGERS",true)
	config.conditionalSet("ENABLED_LOGS",{["dcore"] = true,["command"] = true,["error"] = true,["updater"] = true})
	config.save() -- Saving the config for later usage!
end

-- Use native Globals
if(not _G["cleanG"])then
	_G["cleanG"] = _G
else
	local clean = _G["cleanG"]
	_G = clean
	_G["cleanG"] = clean
end

local apis_loaded = {}

local firstError = true

local file_used = {}
function print_log(file,text)
	if(config.ENABLED_LOGS[file])then
		local logfile = fs.open(config.DIR_LOGS.."/"..file, file_used[file] and "a" or "w")
		if(logfile and type(text)=="string")then
			if(not file_used[file])then file_used[file] = true end
			logfile.writeLine(text)
			logfile.close()
		end
	else
		if(not file_used[file])then
			local logfile = fs.open(config.DIR_LOGS.."/"..file, file_used[file] and "a" or "w")
			file_used[file] = true
			if(logfile)then
				logfile.writeLine("This file was disabled in the configurations!")
				logfile.close()
			end
		end
	end
end

function requireAPI(...)
	local tArgs = { ... }
	for i=1,#tArgs do
		-- Check if api is existent
		if(fs.exists(config.DIR_APIS.."/"..tArgs[i]))then
			if(apis_loaded[tArgs[i]]~=true)then
				-- Prevent double threading this
				apis_loaded[tArgs[i]] = false
				print_log("dcore","[API][MAIN] Loading "..config.DIR_APIS.."/"..tArgs[i])
				local didLoad = os.loadAPI(config.DIR_APIS.."/"..tArgs[i])
				if(didLoad)then
					for k,v in pairs(_G[tArgs[i]]) do
						print_log("dcore","[API][MAIN]["..tArgs[i].."] Loading "..type(v).." "..k.." --> "..tArgs[i].."."..k.."")
					end
				else
					print_log("dcore","[API][MAIN] DID NOT LOAD "..config.DIR_APIS.."/"..tArgs[i].."; error occurred out of nowhere, might have been loaded already!")
				end
				apis_loaded[tArgs[i]] = true
				--Load apis from mods-folders with same name
				loadSimilarApis(tArgs[i])
			end
		else
			print_log("dcore","[API][MAIN] DID NOT load "..config.DIR_APIS.."/"..tArgs[i].."; not found")
			loadSimilarApis(tArgs[i])
		end
	end
end

function isModEnabled(modName)
	if(fs.exists(":dungeon/mods/"..modName))then
		local status = false
		local file = fs.open(":dungeon/mods/"..modName.."/mod.info", "r")
		if(file)then
			modinfo = textutils.unserialize(file.readAll())
			status = (modinfo["active"] or false)
			file.close()
		end
		return status
	end
	return
end

function Error(text,level)
	print_log("error","[ERROR]   "..text)
	error(text,level or 3)
end

function Warning(text)
	print_log("error","[WARNING] "..tostring(text))
end

function loadSimilarApis(_forceName)
	-- File name
	local file_name = tostring(_forceName) or "--"
	-- get all mod dirs
	local l = fs.list(config.DIR_MODS)
	
	for i=1,#l do
		if(isModEnabled(l[i]))then
			-- l[i] = Modname
			local pathToAPIFile = config.DIR_MODS.."/"..l[i].."/apis/"..file_name
			if(fs.exists(pathToAPIFile))then
				print_log("dcore","[API]["..l[i].."] Loading mod-api "..pathToAPIFile.."")
				-- Load functions of Mod API's files
				if(_G[file_name]==nil)then _G[file_name] = {} end
				local fenv = _G[file_name]
				fenv["config"] = config		
				
				local tEnv = setmetatable(fenv, { __index = _G } )
				local fnAPI, err = loadfile(pathToAPIFile)
				if fnAPI then
					setfenv( fnAPI, tEnv )
					local ok, err = pcall( fnAPI )
					if not ok then
						print_log("error","[API]["..l[i].."] While loading "..pathToAPIFile.."; ")
						if(firstError)then
							if(term.isColor())then term.setTextColor(colors.red) end
							print("error found while loading api files, check logs/error for more informations! "..err)
							term.setTextColor(colors.white)
							firstError = false
						end
					end
				else
					print_log("error","[API]["..l[i].."] While loading "..pathToAPIFile.."; ")
					if(firstError)then
						if(term.isColor())then term.setTextColor(colors.red) end
						print("error found while loading api files, check logs/error for more informations! "..err)
						term.setTextColor(colors.white)
						firstError = false
					end
				end
				for k,v in pairs(tEnv) do
					print_log("dcore","[API]["..l[i].."]["..file_name.."] Loading "..type(v).." "..k.." --> "..file_name.."."..k.."")
					_G[file_name][k] = v
				end   
			end
		else
			print_log("dcore","[API]["..l[i].."] Is disabled by client, won't be loaded!")
		end
	end
end

function runFileInAllMods(_fileName)
	-- File name
	local file_name = tostring(_fileName) or "--"
	
	print_log("dcore","[EVENT] STARTED EVENT "..file_name.." !")
	-- get all mod dirs
	local l = fs.list(config.DIR_MODS)
	for i=1,#l do
		-- l[i] = Modname
		local pathToAPIFile = config.DIR_MODS.."/"..l[i].."/event/"..file_name
		if(fs.exists(pathToAPIFile))then
			print_log("dcore","[EVENT]["..file_name.."]["..l[i].."] Starting "..pathToAPIFile.."")
			local tEnv = setmetatable({}, { __index = _G } )
			local fnAPI, err = loadfile(pathToAPIFile)
			if fnAPI then
				setfenv( fnAPI, tEnv )
				local ok, err = pcall( fnAPI )
				if not ok then
					print_log("error","[EVENT]["..file_name.."]["..l[i].."] While loading "..pathToAPIFile.."; ")
					if(firstError)then
						if(term.isColor())then term.setTextColor(colors.red) end
						print("error found while loading api files, check logs/error for more informations! "..err)
						term.setTextColor(colors.white)
						firstError = false
					end
				end
			else
				print_log("error","[EVENT]["..file_name.."]["..l[i].."] While loading "..pathToAPIFile.."; ")
				if(firstError)then
					if(term.isColor())then term.setTextColor(colors.red) end
					print("error found while loading api files, check logs/error for more informations! "..err)
					term.setTextColor(colors.white)
					firstError = false
				end
			end
		end
	end
end

-- 1.20
function getEngineVersion()
	return 120
end
function getBuild()
	return 1
end

-- 0 = pre-alpha, 1 = alpha, 2 = beta, 3 = realese
function version()
	return "0.12b";
end

function getNBTStringFromTable(t)
	local function tableToNBT(t)
		local nbt = ""
		-- None-Table inputs first for easier debugging
		for k,v in pairs(t) do
			if(type(v)~="table")then
				if(t[1]==nil)then
					if(type(v)~="string" or v=="1b" or v=="0b")then
						if(type(v) == "boolean")then
							nbt = nbt..k..":"..tostring(v)..","
						else
							if(type(v) == "function")then -- ERROR condition
								for key,val in pairs(t) do
									print(key..":"..tostring(val))
								end
								error("[apis/dcore:222]: "..tostring(v).." got a function!")
							end
							nbt = nbt..k..":"..v..","
						end
					else
						nbt = nbt..k..":\""..v.."\","
					end
				else
					nbt = nbt..v..","
				end
			end
		end	
		-- Table inputs later for easier debugging
		for k,v in pairs(t) do
			if(type(v)=="table")then
				if(v[1]~=nil)then
					nbt = nbt..k..":["..string.sub(tableToNBT(v),1,-2).."],"
				else
					if(type(k)~="number")then
						nbt = nbt..k..":{"..string.sub(tableToNBT(v),1,-2).."},"
					else
						nbt = nbt.."{"..string.sub(tableToNBT(v),1,-2).."},"
					end
				end
			end
		end
		return nbt 
	end
	if(type(t)=="table")then
		return "{"..string.sub(tableToNBT(t),1,-2).."}"
	else
		return ""
	end
end
function convertTableToNBT(t)
	return getNBTStringFromTable(t)
end
function convertNBTtoTable(startString)
	local function getCharAtPos(str,pos) return string.sub(str,pos,pos)	end
	local str = startString
	local t = {}
	local err = false
	if(getCharAtPos(str,1)~="{" and getCharAtPos(str,1)~="[")then err = true Warning("[NBTtoTable] Wrong start of NBT! \""..getCharAtPos(str,1).."\" ("..startString..")") end
	local isBlocky = (getCharAtPos(str,1) == "[")
	str = str:sub(2,-1)
	local keyCount = 0
	while str:len()>0 and not err and str~="}" and str~="]" do
		local key
		local value
	
		-- Find key (or value if it is a list)
		local i = 1
		while (string.match(getCharAtPos(str,i),"%w") and i<str:len()) do
			key = (key or "")..(getCharAtPos(str,i))
			i = i + 1
		end
		if(not (getCharAtPos(str,i)==":" or (getCharAtPos(str,i)=="," and isBlocky)))then Warning("[NBTtoTable] End of key error \""..getCharAtPos(str,i).."\" (key = "..key..") ("..startString..") "..tostring(isBlocky).."") err = true end
		if(getCharAtPos(str,i)=="," and isBlocky)then
			value = key
			key = keyCount
			keyCount = keyCount + 1
		else
			str = str:sub(i+1,-1)
			local function doString()
				local j = 2
				while ((not (getCharAtPos(str,j)=="\"" and getCharAtPos(str,j-1)~="\\")) and (j)<str:len()) do
					value = (value or "")..(getCharAtPos(str,j))
					j = j + 1
				end
				t[key] = (value)
				str = str:sub(j+1,-1)
			end
			local function doNumber()
				local j = 1
				-- string.match(getCharAtPos(str,j),"%w") or getCharAtPos(str,j)=="." or (getCharAtPos(str,j)=="-" and j==1)
				while (getCharAtPos(str,j)~="," and (j)<str:len()) do
					value = (value or "")..(getCharAtPos(str,j))
					j = j + 1
				end
				local typeIdentifier = value:sub(-1,-1)
				-- Remove type identifier
				str = str:sub(j,-1)
				local v = value:sub(1,-2)
				if(tonumber(v) or string.len(v)==0)then
					-- Boolean
					if(typeIdentifier=="b")then
						t[key] = ("1"==v and true or false)
					else -- Number of some kind
						if(tonumber(typeIdentifier))then
							t[key] = tonumber(v..typeIdentifier)
						else
							t[key] = tonumber(v)
						end
					end
				else
					t[key] = value
				end
			end
			local function doTable()
				local j = 2
				local openSwrily = (getCharAtPos(str,1)=="{" and 1 or 0)
				local openBlocky = (getCharAtPos(str,1)=="[" and 1 or 0)
				local isString = false
				local bracketString = getCharAtPos(str,1)
				while ((openSwrily>=1 or openBlocky>=1) and (j)<str:len()) do
					bracketString = bracketString..(getCharAtPos(str,j))
					if(getCharAtPos(str,j)=="{" and not isString)then openSwrily = openSwrily + 1 end
					if(getCharAtPos(str,j)=="[" and not isString)then openBlocky = openBlocky + 1 end
					if(getCharAtPos(str,j)=="]" and not isString)then openBlocky = openBlocky - 1 end
					if(getCharAtPos(str,j)=="}" and not isString)then openSwrily = openSwrily - 1 end
					if(getCharAtPos(str,j)=="\"" and getCharAtPos(str,j-1)~="\\")then
						isString = not isString
					end
					j = j + 1
				end
				t[key] = convertNBTtoTable(bracketString)
				str = str:sub(bracketString:len()+1,-1)
			end

			-- Find Value
			-- Is number
			if(string.match(getCharAtPos(str,1),"%w") or getCharAtPos(str,1)=="-")then
				doNumber()
				-- Is string
			elseif(getCharAtPos(str,1)=='"')then
				doString()
			elseif(getCharAtPos(str,1)=='{' or getCharAtPos(str,1)=='[')then
				doTable()
			else
				Warning("[NBTtoTable] Invalid stuff type >"..getCharAtPos(str,1).."<")
				err = true
			end
			if(getCharAtPos(str,1)~=",")then err = true Warning("[NBTtoTable] Invalid end of value! Got \""..getCharAtPos(str,1).."\" ("..startString..")") end
		end
		-- Remove something?
		str = str:sub(2,-1)
	end
	return t
end
function convertNBTToTable(s)
	return convertNBTtoTable(s)
end

-- /////////////
-- Grabbing system function and changing them for our use
-- /////////////

-- Custom type definitions for various stuff
if(not dcore)then
	local customTypeRegister = {}
	local nativeType = type

	function getTypeOf(data)
		if(nativeType(data)=="table")then
			local meta = getmetatable(data)
			if(meta)then
				if(meta["type"])then
					for k,v in pairs(customTypeRegister) do
						if(v(data))then
							return k
						end
					end
				end
			end
		end
		return nativeType(data)
	end

	_G["type"] = getTypeOf

	function registerCustomType(typeName,typeFunction)
		if(typeFunction)then
			customTypeRegister[typeName] = typeFunction
		else
			customTypeRegister[typeName] = function(t) if((getmetatable(t)["type"] or "") == typeName)then return true end end
		end
	end

	-- ASYNC Grabbing to prevent timeout's
	local nativeExecAsync = commands.execAsync
	local nativeAsyncCommands = {}
	local nativeSleep = sleep

	local asyncCounter = 0
	_G["sleep"] = function(...)
		asyncCounter = 0
		return nativeSleep(unpack(arg))
	end
	function checkForAsyncTimeout()
		asyncCounter = asyncCounter + 1
		if(asyncCounter>=config.ASYNC_TIMEOUT_MAXIMUM)then
			sleep(0.05)
		end
	end
	_G["commands"]["execAsync"] = function(...)
		checkForAsyncTimeout()
		return nativeExecAsync(unpack(arg))
	end
	for k,v in pairs(_G["commands"]["async"]) do
		nativeAsyncCommands[k] = v
		_G["commands"]["async"][k] = function(...)
			checkForAsyncTimeout()
			return nativeAsyncCommands[k](unpack(arg))
		end
	end

	if(config.ENABLE_SHUTDOWN_TRIGGERS)then
		local nativeShutdown = os.shutdown
		_G["os"]["shutdown"] = function()
			runFileInAllMods("shutdown")
			nativeShutdown()
		end

		local nativeReboot = os.reboot
		_G["os"]["reboot"] = function()
			runFileInAllMods("shutdown")
			nativeReboot()
		end
	end

	_G["getRAE"] = function(a)
		if(not a)then error("Nil is not a valid input",2) end
		if(#a>0)then return a[math.random(#a)] end
	end
	
	-- DEVELOPER MODE ACTIVATED
	if(config.ENABLE_DEVELOPER_MODE)then
		-- Custom Error output to ingame chat with fuse to be sure the computer does not go crazy on us
		local fuse = true
		local nativeError = error
		local customError = function(...)
			local text = ""
			if(fuse)then
				for i=1,#arg-2 do
					text = text.."\""..(tostring(arg[i]) or "").."\","
				end
				if(arg[#arg-1])then
					text = text.."\""..(tostring(arg[#arg-1]) or "").."\""
				end
				commands.execAsync("/say An error happened! "..text.."")
			
				_G["error"] = nativeError			
				local nativeWrite = write
			
				fuse = false
			end
			return nativeError(unpack(arg))
		end
		_G["error"] = customError
	end
	runFileInAllMods("boot")
end

-- maybe grab commands executed, and but them in table to print when system shuts down unexpected


print_log("dcore","[API][DCORE] Loaded dcore ?")
print_log("error","This is where the Errors can be found")
print_log("command","This is where the executed Commands can be found")
