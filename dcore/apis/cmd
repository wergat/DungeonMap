-- Channel for slave -> master CMD communication
dcore.openChannel(23)



local variableFactor = 5
-- Change this to some value. 1 is recommanded.
-- can be set to 1/10 or 20
-- Good performance with 1/10th

-- Runs command command, afterwards calls function func
local storedCommands = {}

function newSlaveComputer(id)
	return {["state"] = "free",["timeout"] = 0,["id"] = id,["function"] = nil,["workingOnAsync"] = false}
end

local slaveComputers = {newSlaveComputer(11),newSlaveComputer(12),newSlaveComputer(13),newSlaveComputer(14),newSlaveComputer(15),newSlaveComputer(16),newSlaveComputer(17),newSlaveComputer(18)}


local cores = #slaveComputers

local runThreads = {}
local commandsStarted = 1
local commandsExecuted = 1
local asyncStarted = 1
local asyncFeedback = 1

function getCommandStats()
	return {
		["commandsStarted"] = commandsStarted,
		["commandsExecuted"] = commandsExecuted,
		["asyncStarted"] = asyncStarted,
		["asyncFeedback"] = asyncFeedback,
		["amountOfStoredCommands"] = #storedCommands,
	}
end

-- run(command[,function to start on return][,useAsnyc])
function run(command,arg)
	if(type(arg) == "function")then
		table.insert(runThreads,{["command"] = command,["func"] = arg,["async"] = false})
		commandsStarted = commandsStarted + 1
	else
		asyncStarted = asyncStarted + 1
		if(arg or arg == nil)then arg = true else arg = false end
		table.insert(runThreads,{["command"] = command,["func"] = nil,["async"] = arg})
	end
end

function getSlaveComputerData()
	return slaveComputers
end

function getRunningCommands()
	return storedCommands
end



function getWaitingCommands()
	return runThreads
end

function getSlaveComputerByID(id)
	for i=1,#slaveComputers do
		if(slaveComputers[i].id == id)then
			return i
		end
	end
end

function countFreeSlaveComputers()
	local count = 0
	for k,v in pairs(slaveComputers)do
		if(v.state == "free")then
			count = count + 1
		end
	end
	return count
end


function findFreeSlaveComputer(asnyc)
	for k,v in pairs(slaveComputers)do
		if(v.state == "free")then
			return k
		end
	end
end

function countWaitingCommands()
	local count = 0
	for i=1,#runThreads do
		if(runThreads[i])then
			count = count + 1
		end
	end
	return count
end

local function chatchNewThreads()
	local targetSlave = findFreeSlaveComputer()
	local waitingCommands = countWaitingCommands()
	
	--print(waitingCommands..":"..packetLimit)
	
	
	for i=1,#slaveComputers do
		if(slaveComputers[i].state == "working")then
			slaveComputers[i].timeout = slaveComputers[i].timeout + 1
			if(slaveComputers[i].timeout >= 20)then
				slaveComputers[i].state = "free"
				slaveComputers[i]["function"] = nil
				slaveComputers[i]["timeout"] = 0
			end
		end
	end
	while #runThreads>0 and targetSlave do
		local threadID = math.random(999999999)
		while(storedCommands[threadID])do
			threadID = math.random(999999999)
		end
		-- Mark the slave as occupied, if thats the case.
		slaveComputers[targetSlave].state = "working"
		slaveComputers[targetSlave].timeout = 0
				
		-- If the slave should sent a return, save the function
		if(not runThreads[1]["async"])then
			storedCommands[threadID] = true
			-- Transmit the command to the slave
			dcore.send(22,slaveComputers[targetSlave].id,{runThreads[1]["command"],threadID})
			-- Remove the command from the list
			slaveComputers[targetSlave]["function"] = runThreads[1]["func"]
			slaveComputers[targetSlave]["workingOnAsync"] = false
			table.remove(runThreads,1)
		else -- Slave is given all the Async Commands we got, at most ten, thoguh
			local packetLimit = math.floor((math.sqrt((waitingCommands*cores*variableFactor+1)) + 10) / cores)
			local t = {}
			local u = nil
			local pointer = 1
			local timeout = 0
			repeat
				if(runThreads[pointer]["async"])then
					u = runThreads[pointer]["command"]
					table.remove(runThreads,pointer)
				end
				pointer = pointer + 1
				timeout = timeout + 1
				if(u)then t[(#t+1)] = u u = nil end
			until pointer>packetLimit or pointer > #runThreads or #t>packetLimit or timeout>=packetLimit
			dcore.send(22,slaveComputers[targetSlave].id,{t,threadID})
			
			storedCommands[threadID] = true
			slaveComputers[targetSlave]["function"] = nil
			slaveComputers[targetSlave]["workingOnAsync"] = true
		end
		
		-- Remove the current command from the list of todo threads.
		
		-- FInd the next free slave, if there is one!
		targetSlave = findFreeSlaveComputer()
	end
end

function stackCheckerLoop()
	while true do
		chatchNewThreads()
		sleep(0.05)
	end
end



local function chatchDoneCommands()
	local event = {os.pullEvent("dcore_cmd")}
	local tEvent = textutils.unserialize(event[2])
	if(tEvent)then
		local id = getSlaveComputerByID(tEvent[4])
		local message = tEvent[5]
		if(tEvent[3] == 23 and slaveComputers[id].state == "working" and type(message) == "table")then
			if(storedCommands[tonumber(message[1][1])])then
				if(slaveComputers[id]["function"])then
					slaveComputers[id]["function"](message[1][2])
					slaveComputers[id]["function"] = nil
					commandsExecuted = commandsExecuted + 1
				else asyncFeedback = asyncFeedback + 1 end
				storedCommands[tonumber(message[1][1])] = nil
				slaveComputers[id].state = "free"
				slaveComputers[id]["timeout"] = 0
			end
		end
	else
		print("Error: \""..tostring(event[2]).."\"")
	end
end

function chatchDoneCommandsLoop()
	while true do
		chatchDoneCommands()
	end
end


-- This API might get removed at some point, just wait for it...

function getAllPlayerNames(customSearch)
	local r,t = commands.xp(0,(customSearch or "@a"))
	local players = {}
	if(r)then
		for i=1,#t do
			players[#players+1] = string.match(t[i],"%a+$")
		end
		return players
	else
		print(t[1])
		return nil
	end
end