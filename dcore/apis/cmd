local modem = peripheral.wrap( "top" )
-- CMD PORT: -> 22 -> 23
modem.open(23)


local variableFactor = 5
-- Change this to some value. 1 is recommanded.
-- can be set to 1/10 or 20
-- Good performance with 1/10th

-- Runs command command, afterwards calls function func
local storedCommands = {}
local slaveComputers = {[11] = true,[12] = true,[13] = true,[14] = true,[15] = true,[16] = true,[17] = true,[18] = true}

local cores = 4

local runThreads = {}

-- run(command[,function to start on return[,useAsnyc]]
function run(command,arg)
	if(type(arg) == "function")then
		table.insert(runThreads,{command,arg,false})
	else
		if(arg or arg == nil)then arg = true else arg = false end
		table.insert(runThreads,{command,arg or (function() end),arg})
	end
end

function getSlaveComputerData()
	return slaveComputers
end

function getRunningCommands()
	return storedCommands
end

function getWaitingCommands()
	return runThreads
end

function findFreeSlaveComputer(asnyc)
	for k,v in pairs(slaveComputers)do
		if(v)then
			return k
		end
	end
end

local function chatchNewThreads()
	while true do
		local targetSlave = findFreeSlaveComputer()
		local waitingCommands = #runThreads
		local packetLimit = math.floor((math.sqrt((waitingCommands*cores*variableFactor+1)) + 10) / cores)
		print(waitingCommands..":"..packetLimit)
		while #runThreads>0 and targetSlave do
			local threadID = math.random(999999999)
			while(storedCommands[threadID])do
				threadID = math.random(999999999)
			end
			-- Mark the slave as occupied, if thats the case.
			slaveComputers[targetSlave] = false
					
			-- If the slave should sent a return, save the function
			if(not runThreads[1][3])then
				storedCommands[threadID] = runThreads[1][2]
				-- Transmit the command to the slave
				modem.transmit(22,targetSlave,{runThreads[1][1],threadID})
				-- Remove the command from the list
				table.remove(runThreads,1)
			else -- Slave is given all the Async Commands we got, at most ten, thoguh
				local t = {}
				local u = nil
				local pointer = 1
				local timeout = 0
				repeat
					if(runThreads[pointer][3])then
						u = runThreads[pointer][1]
						table.remove(runThreads,pointer)
					end
					pointer = pointer + 1
					timeout = timeout + 1
					if(u)then t[(#t+1)] = u u = nil end
				until pointer>packetLimit or pointer > #runThreads or #t>packetLimit or timeout>=packetLimit
				modem.transmit(22,targetSlave,{t,threadID})
				storedCommands[threadID] = function() end
			end
			
			-- Remove the current command from teh list of todo threads.
			
			-- FInd the next free slave, if there is one!
			targetSlave = findFreeSlaveComputer()
		end
		sleep(0.05)
	end
end

local function chatchDoneCommands()
	while true do
		local event, modemSide, senderChannel,replyChannel, message, senderDistance = os.pullEvent("modem_message")
		if(senderChannel == 23 and slaveComputers[replyChannel] ~= nil and type(message) == "table")then
			if(storedCommands[tonumber(message[1])])then
				storedCommands[tonumber(message[1])](message[2])
				storedCommands[tonumber(message[1])] = nil
				slaveComputers[replyChannel] = true
			end
		end
	end
end
function start()
	parallel.waitForAny(chatchNewThreads,chatchDoneCommands)
end



-- This API might get removed at some point, just wait for it...

function getAllPlayerNames(customSearch)
	local r,t = commands.xp(0,(customSearch or "@a"))
	local players = {}
	if(r)then
		for i=1,#t do
			players[#players+1] = string.match(t[i],"%a+$")
		end
		return players
	else
		print(t[1])
		return nil
	end
end