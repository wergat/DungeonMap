dcore.requireAPI("gendata")

data = {}
data["seed"] = 12342 -- math.random(10000)
math.randomseed(data["seed"])
data["subSeed"] = math.random(10000)

data["generationHeightMax"] = 5.6
data["generationHeightMax_ruins"] = 8.4
data["generationBaseHeight"] = 1
data["generationBaseHeight_ruins"] = 3
data["heightMax_ruins"] = 14

-- move this to boss-dlc
-- Boss room has a chance of bossRoomChance_Small in bossRoomChance_Big
data["bossRoomChance_Big"] = 20 
data["bossRoomChance_Small"] = 1

-- TODO: rework, update to new gendata standarts
-- Biomes: 0: Nothing    1:Fortress      ,2:Nether  ,3:Water Temple,4:Desert Temple,5:Forest,6:Cave,7:Dark Forest  ,8:Mesa       ,9:Ice Cave      ,10:Ruins   ,11:Miner's Cave,12: Abbondend
-- Biomes: 101: Special Dropluck room ,102: Boss room
data["biome_levels"] = {{2,1,2,6},{1,3,6,6,9},{4,5,7,8}}

local chunk_sizeX = math.random(15,25)
local chunk_sizeY = math.floor(375/chunk_sizeX)

local function positive(num) if(num<0)then return num*-1 else return num end end

-- aka Stairs and holes
-- returns start and ending of stairs/holes in y coords
function getVerticalConnectionBottomAndTop(x,z)
 local height = generation.getEffectiveHeightOfPillar(x,z)
 math.randomseed(data["seed"]+(((x*3-3)+data["subSeed"])*(z-13))+(z*-2))
 local bottom = math.random(math.floor(height/2+0.5))
 local top = math.random(bottom+1,height)
 return bottom,top
end
function getVerticalConnection(x,z)
 local height = generation.getEffectiveHeightOfPillar(x,z)
 local connectionType = nil
 math.randomseed(generation.giveSeed(x,z))
 local bottom = 0
 local top = 0
 -- 1 in 6 chance for stairs/hole
 if(math.random(6)==3)then
  bottom = math.random(math.floor(height/2+0.5))
  top = math.random(bottom+1,height)
  -- 2 in 3 chance for stairs, all other are holes
  if(math.random(3)>1)then
   connectionType = "stairs"
  else
   connectionType = "hole"
  end
 end
 return connectionType,bottom,top
end


-- BIOME GENERATION
-- uses y as z, the minecraft-y-coord is the level
-- like seen from above
function getRandomSeedForBiome(x,y,xfactor,yfactor,b,level)
 local realXPos = x+(chunk_sizeX*xfactor)
 local realYPos = y+(chunk_sizeY*yfactor)
 local realXChunkPos = math.floor(realXPos/chunk_sizeX)
 local realYChunkPos = math.floor(realYPos/chunk_sizeY)
 
 local partA = realXChunkPos*(generation.data["seed"]%(13+(level)))+(12*(generation.data["subSeed"]%34))
 local partB = realYChunkPos*(generation.data["seed"]%(17+(level)))+(34*(generation.data["subSeed"]%12))
 return (partA*b)+(partB*level)
end 



function getBiomeByPosition(x,y,level)
 if(level > 3)then level = 3 end
 local xinchunk = x%chunk_sizeX -- X Position in 0/0 chunk
 local yinchunk = y%chunk_sizeY -- Y Position in 0/0 chunk
 
 local lowest_distance = 200
 local lowest_distance_biome = 0
 
 for b=1,#generation.data["biome_levels"][level] do
  for xfactor=-1,1 do
   for yfactor=-1,1 do
    math.randomseed(generation.getRandomSeedForBiome(x,y,xfactor,yfactor,b,level))
    	
    local biomecenterx = math.random(chunk_sizeX)+(chunk_sizeX*xfactor) -- X center of biome b in Chunk xfactor/yfactor relative to 0/0 chunk
    local biomecentery = math.random(chunk_sizeY)+(chunk_sizeY*yfactor) -- Y center of biome b in Chunk xfactor/yfactor relative to 0/0 chunk
	local distance = positive(xinchunk - biomecenterx) + positive(yinchunk - biomecentery)
	
    if(distance<lowest_distance)then
     lowest_distance = distance
     lowest_distance_biome = b
    end
	
   end
  end
 end 
 return generation.data["biome_levels"][level][lowest_distance_biome]
end

-- uses minecraft xyz as inputs
function getRoomsBiomeByPostion(x,y,z)
 return generation.getBiomeByPosition(x,z,y)
end


-- HEIGHT GENERATION
function getNoiseByPosition(x,y) -- 
 math.randomseed(generation.data["seed"]+((x+generation.data["subSeed"])*y)+(y*4))
 return math.random(generation.data["generationHeightMax"]*10)/10
end
function getHeightByPosition(x,y)
 local corners = (generation.getNoiseByPosition(x-1,y-1)+ generation.getNoiseByPosition(x+1, y-1)+ generation.getNoiseByPosition(x-1, y+1)+ generation.getNoiseByPosition(x+1, y+1) ) / 8 -- 4
 local sides   = (generation.getNoiseByPosition(x-1,y)  + generation.getNoiseByPosition(x+1, y)  + generation.getNoiseByPosition(x, y-1)  + generation.getNoiseByPosition(x, y+1) ) /  4 -- 2
 local center  =  generation.getNoiseByPosition(x, y) / 2 -- 2
 local noise = math.floor((corners + sides + center)/(2))
 return noise
end
function getEffectiveHeightOfPillar(x,y)
 return generation.getHeightByPosition(x,y)+generation.data["generationBaseHeight"]
end

-- API functions
function setSeed(_seed)
 generation.data["seed"] = _seed
 math.randomseed(data["seed"])
 generation.data["subSeed"] = math.random(10000)
 chunk_sizeX = math.random(15,25)
 chunk_sizeY = math.floor(375/chunk_sizeX)
end
function getChunkSize()
 return chunk_sizeX,chunk_sizeY
end
function getSeed()
 return generation.data["seed"]
end
-- returns a seed generated with the args given
function giveSeed(...)
 local seed = generation.data["seed"]
 for k,v in ipairs(arg) do
  if(type(v)=="number")then
   seed = seed + math.floor((((v*5-42)+data["subSeed"])*(k*-4*((v%4)+3)))+(v+21)/23)
  end
 end
 return seed
end








-- remove later:

-- For 3D drawing, to be put into the Dev-Tools
local blocks = {"98 0","87","95 11","12","35 13","1","5 5","159 0","174 0","98 2","4","45"}
function getBlockAtPosition(x,y,z)
 if(y<=3)then
  if(isBossRoom(x,z))then
   return "4"
  elseif(isSpecialRoom(x,y,z))then
   return "41"
  end
 end
 if(blocks[getChunkBiomeAtPostion(x,y,z)]~=nil)then
  return blocks[getChunkBiomeAtPostion(x,y,z)]
 else
  return "89"
 end
 --return rooms[getChunkBiomeAtPostion(x,y,z)]["blockID"]
end
